Vue

# MVVM的原理

第一个M  model对应的是vue组件中的data数据部分

第二个v view视图，对应的是vue的模板

第三个vm  组件实例，主要有两个功能，一个数据绑定，一个事件监听。





# Vue响应式原理

vue2.0使用的是Object.defineProperty实现数据劫持，配合发布订阅者模式实现响应式。

①设置一个Observer观察者，遍历data中的属性，如果data对象中含有子对象，还需要递归遍历，通过Object.defineProperty为其添加set和get方法。从而实现数据劫持

②设置一个compile模板解析器，将模板中的变量替换成数据，然后初始化渲染。当模板中变量被调用，就会触发对应的get方法，创建出一个watcher订阅者实例，再将指令对应节点的更新函数，绑定到watcher实例的update方法里，再将watcher实例推入到调度中心dep中。

③设置一个调度中心dep，里面存放所有的订阅者数组，当数据被修改时，就会通过dep.notify通知调度中心，然后调度中心找到对应的订阅者触发对应的update方法



缺点：①需要递归遍历子对象。②无法通过下标响应式的修改数据③新增属性没有响应式



Vue3.0中使用proxy来实现数据代理，只需要一次代理就可以实现整个对象的数据劫持。主要分为ref和reactive定义响应式数据，ref如果传入基本类型数据，底层还是通过Object.defineProperty实现的，reactive是使用proxy实现的。



# Vue.$set原理

Vue.$set(target,key,value)

首先会判断传进来的是否是数组，如果是数组的话，就会在内部调用splice方法修改数组，因为vue内部重写了splice方法，这是响应式的。

如果传进来的是对象，往对象上新增属性，就会调用defineReactive方法，实际上还是通过Object.defineProperty再走一遍数据劫持和发布订阅





# 双向绑定

vue中通过v-model实现双向绑定，v-model实际上是v-bind和v-on的语法糖，通过v-bind将data中的数据绑定到模板中，然后通过v-on监听事件，修改data中的数据，实现双向绑定的效果。其实就是react中的受控组件。



# computed和watch的区别

computed是计算属性，它是有缓存的，它依赖于data或者props中的数据，只有当依赖的属性发生改变时，它才会重新计算。

vue3.0中computed语法改变了，转换成computed(()=>)回调函数的方式。

computed中不支持异步操作。

watch是侦听器，当它监听到的数据发生改变，就会触发对应的回调函数，它是没有缓存的，但是可以支持异步操作。



# keep-alive组件

可以用keep-alive组件包裹需要被缓存状态的组件，组件被keep-alive包裹后，就会失去了created，和destroyed生命周期，多了actived，deactived生命周期，即组件不会再被重复的创建与销毁





# v-if和v-show的区别

v-if是通过对真实DOM的添加或删除来实现元素的显示与隐藏

v-show是通过添加display：none的属性实现，所以v-show在频繁的条件下更好



# v-for和v-if为什么不能连用

①因为vue2.0中v-for的优先级会高于v-if，它会先进行遍历渲染，然后再通过v-if判断是否要删除DOM元素，导致性能损耗。

②vue3.0中v-if优先级高于v-for，因为v-if先执行，v-for后执行，所以用了v-for定义的变量就会报错。 v-for item in arr  item.name报错

解决办法：if在for外层，可以套个template模板，v-if

for在if外层，可以提前过滤数据





# data为什么是个函数而不是对象

因为vue中每个组件都要有一个data，而且每个组件都可能会被调用多次，如果data是一个对象的话，那么这些组件都公用了一个data对象，导致数据冲突。如果data是一个函数的话，每次组件实例化，都会重新创建出一个data对象，实现数据隔离。





# nextTick的作用

在DOM下一次更新渲染结束后，调用指定的回调函数，在该回调函数中可以获取到异步更新后的最新的DOM元素。

场景 ：我们修改了响应式数据，然后想要立刻获取到最新的DOM，就需要用nextTick

nextTick的原理：本质上是对事件循环机制的一种利用，它的内部会把回调函数封装成宏任务或者是微任务。这取决于运行环境是否支持promise，如果支持promise都会封装成微任务，然后推入微任务队列末尾，按照事件循环机制执行。





# vue异步更新原理

vue的视图更新是异步的，当响应式数据发生改变时，vue会开启一个异步任务队列，将订阅该数据的订阅者推入队列当中，缓冲所有的数据变更，如果同一数据变更多次，那么对应的订阅者也只会被推入队列一次，等到下一次循环tick的时候，vue会刷新任务队列，调用对应订阅者的update方法，更新视图。



# 异步组件的优点

vue3.0通过defineAsyncComponent的方式定义异步组件，异步组件一般会配合Suspense使用，优点，可以轻松的实现骨架屏效果。

②优化打包，如果直接同步导入组件，那么所有文件都会被打包到一个js文件中，打包出来的js文件很大，导致加载时间过长。

如果异步导入组件，那么打包时首次加载没有用到的组件会被拆分出来，暂时不到主包里，只有当该组件被使用时，才会被加载放到主包里



# SPA单页面应用

SPA单页面应用：即所有内容放到一个index.html文档里，在页面初始化加载的时候加载大量的jscss图片等资源，等到页面构建完毕后，用户的操作不会导致页面的重新构建，而是根据路由机制，匹配不同的url动态展示不同的组件。

页面切换速度快，客户端渲染，减轻了服务端压力

缺点：首屏加载大量资源，首屏加载耗时太长



MPA多页面应用，由多个独立的页面构成，每个页面都需要独立的加载jscss等资源。

优点：页面跳转时，每个页面都需要重新构建





# 首屏加载白屏优化

①使用路由懒加载，异步组件的方式。vue2.0中通过箭头函数配合import，vue3.0中通过defineAsyncComponent配合箭头函数，可以配合Suspense骨架屏，优化用户体验。这是因为异步组件在打包时，会被拆分出去，单独打包成一个js文件，不会被打包到主包里，只有当组件被调用时，才会重新加载放到主包里。

②使用图片懒加载的方式，只加载可视区域内的图片

③减少首次加载时的网络请求

④UI组件按需导入



# 路由

路由是实现SPA单页面应用的核心机制，SPA单页面应用，即所有内容放到一个index.html文档里，在页面初始化加载的时候加载大量的jscss图片等资源，等页面构建完毕后，用户的操作不会导致页面的重新构建，而是按照路由机制，匹配不同的url，动态展示不同的路由组件。

路由分两种模式，一种hash路由，url含有#,它是基于window.onhashChange的方式实现的，可以监听到hash值的变化，从而根据不同的hash值动态展示不同的路由组件

history路由，是h5新增的history api实现的，通过history.pushState()方式，将url和相关信息推入到了浏览器的历史记录栈中，从而实现了修改页面的url，同时不会导致页面的刷新。



history路由的缺点：

①用户刷新页面，或者直接输入嵌套路由的地址会出现404错误。这是因为用户手动输入地址，一定会向服务端发起请求，而history路由路径会随着http请求一起发送给服务端，服务端匹配不到对应资源，自然返回了404。需要后端在nginx做配置，如果匹配不到，返回一个index.html文档即可





## 常见的路由导航守卫

①全局导航守卫 

router.beforeEach() 在进入路由组件前触发，常用于鉴权，判断token是否存在等等。

router.beforeResolve()在组件.beforeRouteEnter后触发，很少使用

router.afterEach 全局后置钩子，在进入路由后触发，配合window.scrollTo()滚动到页面顶部



②组件内钩子

组件.beforeRouteEnter 进入组件前调用

beforeRouteUpdate 一般配合params参数使用，因为修改params参数，不会导致路由跳转，也就不会导致组件重渲染。



beforeRouteLeave 离开组件前触发



# 虚拟DOM

虚拟DOM即用js对象形式模拟出真实的DOM结构，真实DOM属性都可以在该js对象上找到。当页面状态发生改变时，就会根据改变的部分重新生成一颗新的虚拟DOM树，新旧虚拟DOM树进行diff比较，计算出最小量更新，然后更新真实DOM。

优点：如果没有虚拟DOM，用户直接操作真实DOM，每一次数据变更都可能导致大量的不必要的DOM操作，浪费浏览器性能



## diff算法

首先判断是否一方是真实DOM节点，如果是真实DOM节点，就调用h函数生成虚拟节点，进行关联。

②如果都是vnode，进行diff比较。判断key和标签名是否相同，如果不同，直接暴力删除oldVnode对应的真实DOM，创建newVnode对应的真实DOM，然后调用patch函数上树。

③如果相同，则进行下一层次比较。判断子节点是否相同，vue采用的是四个指针，四个比对策略，总体来说是从两端到中间的比对策略。



与react的区别：

vue的diff算法是一边比较，一边计算出最小量更新，然后调用patch函数给真实DOM打补丁。react是比较新旧虚拟DOM树，计算出差异，然后将差异保存到差异对象中，最后遍历差异对象更新真实DOM。



# Vite和webpack的区别

启动上，vite是冷启动，启动速度快。vite启动服务器时，无需进行打包编译，直接启动服务器。服务器启动后，浏览器请求相应模块，再对相应模块进行编译处理。而webpack启动时，需要打包编译所有的模块，然后再启动服务器。所以耗时较长

②热更新方面，vite效率更高。当某个模块代码被改动时，vite只需要对该模块进行重编译。而webpack需要对当前模块和当前模块所依赖的模块进行重编译