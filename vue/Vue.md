Vue

# MVVM的原理

第一个M  model对应的是vue组件中的data数据部分

第二个v view视图，对应的是vue的模板

第三个vm  组件实例，主要有两个功能，一个数据绑定，一个事件监听。





# Vue响应式原理

vue2.0使用的是Object.defineProperty实现数据劫持，配合发布订阅者模式实现响应式。

①设置一个Observer观察者，遍历data中的属性，如果data对象中含有子对象，还需要递归遍历，通过Object.defineProperty为其添加set和get方法。从而实现数据劫持

②设置一个compile模板解析器，将模板中的变量替换成数据，然后初始化渲染。当模板中变量被调用，就会触发对应的get方法，创建出一个watcher订阅者实例，再将指令对应节点的更新函数，绑定到watcher实例的update方法里，再将watcher实例推入到调度中心dep中。

③设置一个调度中心dep，里面存放所有的订阅者数组，当数据被修改时，就会通过dep.notify通知调度中心，然后调度中心找到对应的订阅者触发对应的update方法



缺点：①需要递归遍历子对象。②无法通过下标响应式的修改数据③新增属性没有响应式



Vue3.0中使用proxy来实现数据代理，只需要一次代理就可以实现整个对象的数据劫持。主要分为ref和reactive定义响应式数据，ref如果传入基本类型数据，底层还是通过Object.defineProperty实现的，reactive是使用proxy实现的。



# Vue.$set原理

Vue.$set(target,key,value)

首先会判断传进来的是否是数组，如果是数组的话，就会在内部调用splice方法修改数组，因为vue内部重写了splice方法，这是响应式的。

如果传进来的是对象，往对象上新增属性，就会调用defineReactive方法，实际上还是通过Object.defineProperty再走一遍数据劫持和发布订阅





# 双向绑定

vue中通过v-model实现双向绑定，v-model实际上是v-bind和v-on的语法糖，通过v-bind将data中的数据绑定到模板中，然后通过v-on监听事件，修改data中的数据，实现双向绑定的效果。其实就是react中的受控组件。



# computed和watch的区别

computed是计算属性，它是有缓存的，它依赖于data或者props中的数据，只有当依赖的属性发生改变时，它才会重新计算。

vue3.0中computed语法改变了，转换成computed(()=>)回调函数的方式。

computed中不支持异步操作。

watch是侦听器，当它监听到的数据发生改变，就会触发对应的回调函数，它是没有缓存的，但是可以支持异步操作。



# keep-alive组件

可以用keep-alive组件包裹需要被缓存状态的组件，组件被keep-alive包裹后，就会失去了created，和destroyed生命周期，多了actived，deactived生命周期，即组件不会再被重复的创建与销毁





# v-if和v-show的区别

v-if是通过对真实DOM的添加或删除来实现元素的显示与隐藏

v-show是通过添加display：none的属性实现，所以v-show在频繁的条件下更好



# v-for和v-if为什么不能连用

①因为vue2.0中v-for的优先级会高于v-if，它会先进行遍历渲染，然后再通过v-if判断是否要删除DOM元素，导致性能损耗。

②vue3.0中v-if优先级高于v-for，因为v-if先执行，v-for后执行，所以用了v-for定义的变量就会报错。 v-for item in arr  item.name报错

解决办法：if在for外层，可以套个template模板，v-if

for在if外层，可以提前过滤数据





# data为什么是个函数而不是对象

因为vue中每个组件都要有一个data，而且每个组件都可能会被调用多次，如果data是一个对象的话，那么这些组件都公用了一个data对象，导致数据冲突。如果data是一个函数的话，每次组件实例化，都会重新创建出一个data对象，实现数据隔离。





# nextTick的作用

在DOM下一次更新渲染结束后，调用指定的回调函数，在该回调函数中可以获取到异步更新后的最新的DOM元素。

场景 ：我们修改了响应式数据，然后想要立刻获取到最新的DOM，就需要用nextTick

nextTick的原理：本质上是对事件循环机制的一种利用，它的内部会把回调函数封装成宏任务或者是微任务。这取决于运行环境是否支持promise，如果支持promise都会封装成微任务，然后推入微任务队列末尾，按照事件循环机制执行。





# vue异步更新原理

vue的视图更新是异步的，当响应式数据发生改变时，vue会开启一个异步任务队列，将订阅该数据的订阅者推入队列当中，缓冲所有的数据变更，如果同一数据变更多次，那么对应的订阅者也只会被推入队列一次，等到下一次循环tick的时候，vue会刷新任务队列，调用对应订阅者的update方法，更新视图。



# 异步组件的优点

vue3.0通过defineAsyncComponent的方式定义异步组件，异步组件一般会配合Suspense使用，优点，可以轻松的实现骨架屏效果。

②优化打包，如果直接同步导入组件，那么所有文件都会被打包到一个js文件中，打包出来的js文件很大，导致加载时间过长。

如果异步导入组件，那么打包时首次加载没有用到的组件会被拆分出来，暂时不到主包里，只有当该组件被使用时，才会被加载放到主包里



# SPA单页面应用

SPA单页面应用：即所有内容放到一个index.html文档里，在页面初始化加载的时候加载大量的jscss图片等资源，等到页面构建完毕后，用户的操作不会导致页面的重新构建，而是根据路由机制，匹配不同的url动态展示不同的组件。

页面切换速度快，客户端渲染，减轻了服务端压力

缺点：首屏加载大量资源，首屏加载耗时太长



MPA多页面应用，由多个独立的页面构成，每个页面都需要独立的加载jscss等资源。

优点：页面跳转时，每个页面都需要重新构建





# 首屏加载白屏

①使用异步组件路由懒加载的方式，懒加载的路由会被单独